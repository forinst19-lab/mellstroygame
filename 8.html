<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>MELLSTROY.GAME – Neon Pixel Field Optimized</title>
<style>
  body {
    margin: 0;
    background: black;
    overflow: hidden;
  }
  canvas {
    display: block;
  }
</style>
</head>
<body>
<canvas id="canvas"></canvas>

<script>
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");
let W, H;

function resize() {
  W = canvas.width = window.innerWidth;
  H = canvas.height = window.innerHeight;
  init();
}
window.addEventListener("resize", resize);

let particles = [];
let mouse = { x: 0, y: 0, active: false };

function init() {
  particles = [];

  const text = "MELLSTROY.GAME";
  const fontSize = Math.min(W * 0.12, 180); // адаптивный размер шрифта
  const tmpCanvas = document.createElement("canvas");
  const tmpCtx = tmpCanvas.getContext("2d");
  tmpCanvas.width = W;
  tmpCanvas.height = H;
  tmpCtx.font = `bold ${fontSize}px Arial`;
  tmpCtx.textAlign = "center";
  tmpCtx.textBaseline = "middle";
  tmpCtx.fillStyle = "#fff";
  tmpCtx.fillText(text, W / 2, H / 2);

  const imageData = tmpCtx.getImageData(0, 0, W, H);
  const step = 4;

  // определяем границы текста, чтобы не сканировать весь экран
  let minX = W, maxX = 0, minY = H, maxY = 0;
  for (let y = 0; y < H; y += step) {
    for (let x = 0; x < W; x += step) {
      const i = (y * W + x) * 4;
      if (imageData.data[i + 3] > 128) {
        if (x < minX) minX = x;
        if (x > maxX) maxX = x;
        if (y < minY) minY = y;
        if (y > maxY) maxY = y;
      }
    }
  }

  // создаём частицы только в пределах текста
  for (let y = minY; y < maxY; y += step) {
    for (let x = minX; x < maxX; x += step) {
      const i = (y * W + x) * 4;
      if (imageData.data[i + 3] > 128) {
        particles.push({
          x: Math.random() * W,
          y: Math.random() * H,
          homeX: x,
          homeY: y,
          vx: 0,
          vy: 0,
          born: Math.random() * 1000
        });
      }
    }
  }
}

canvas.addEventListener("mousemove", e => {
  mouse.x = e.clientX;
  mouse.y = e.clientY;
  mouse.active = true;
});
canvas.addEventListener("mouseleave", () => (mouse.active = false));

let startTime = null;
function draw(timestamp) {
  if (!startTime) startTime = timestamp;
  const elapsed = timestamp - startTime;

  ctx.clearRect(0, 0, W, H);

  for (const p of particles) {
    if (elapsed < p.born) continue;

    const dx = p.homeX - p.x;
    const dy = p.homeY - p.y;

    if (mouse.active) {
      const mx = p.x - mouse.x;
      const my = p.y - mouse.y;
      const distMouse = Math.sqrt(mx * mx + my * my);
      if (distMouse < 150) {
        const force = (150 - distMouse) / 150;
        const angle = Math.atan2(my, mx);
        p.vx += Math.cos(angle) * force * 6;
        p.vy += Math.sin(angle) * force * 6;
      }
    }

    p.vx += dx * 0.015;
    p.vy += dy * 0.015;
    p.vx *= 0.9;
    p.vy *= 0.9;
    p.x += p.vx;
    p.y += p.vy;

    const glow = 0.6 + Math.sin((p.x + p.y + elapsed * 0.01) * 0.04) * 0.4;
    ctx.fillStyle = `rgba(190,0,255,${0.9 * glow})`;
    ctx.shadowColor = "#d000ff";
    ctx.shadowBlur = 12;
    ctx.fillRect(p.x, p.y, 2.5, 2.5);
  }

  requestAnimationFrame(draw);
}

resize();
requestAnimationFrame(draw);
</script>
</body>
</html>
